= Metanorma conversion guide

This guide presents recommendations, tips, and FAQ to help in the process of converting Word and PDF document format to Metanorma AsciiDoc. It is assumed though, that the reader is already familiar with the Metanorma AsciiDoc markup described in the link:https://www.metanorma.com/author/[official documentation].


== Converting Word/PDF documents to Metanorma: overall process

The overall process can be summarized in these following steps:

. Take a text editor of your choice, and create a new .adoc file.
. Transfer the raw content from the PDF/DOCX file to the .adoc file.
. Apply proper AsciiDoc/Metanorma markup where is needed.
. Compile the .adoc file and check the results.

Simple, right? Well, yes, these are simple steps specially for short documents. But things tend to get quite tedious for longer ones. So, in order to speed up the process, let's start with some recommendations.

== Recommendations

=== Pick a good code editor

Although it is possible to use any plain text editor to edit .adoc files, it is recommended to pick a respected code editor instead, gifted with a good search-and-replace engine and capable of using regular expressions. Some popular ones are: _Notepad++, Atom, Sublime text, VSCode_, among others.


=== Use regular expressions

Imagine that you need to convert a document of 100 pages full of sections and subsections. And after transfering all the raw content to the .adoc file, you decide to go through every section/subsection line making changes like "_3.5.6 Some Title_" to "_==== Some Title_", then "_3.5.7 Another Title_" to "_==== Another Title_", and then the next line, and the next one, and argh... Boring, tedious, tiresome, time-consuming, monotonous, uninspiring, god help me! And that is just naming a case from a bunch! So, for this reason and many others, it is better to use _regular expressions_. 

Regular expressions, or _regex_ for short, is a sequence of characters used to define a search pattern. It is commonly integrated in the search-and-replace engine of code editors and is easy to learn. With this link:https://www.rexegg.com/regex-quickstart.html[Cheat Sheet], you could get on track quickly. But, without ignoring other options in the web.

So, back to the exposed situation, with regex, you would just open the search-and-replace engine, activate regex mode, look for matches to this parttern: "^\d+\.\d+\.\d+ (.+)$", replace them all with: "==== $1", and you're done.

Working with regex will save you a lot of time, specially when it comes to convert long documents.


=== Use AsciiDoc live preview for quick markup checking

One of the reasons we recommend to pick up a good code editor is because the resources it can offer. For instance, many editors give you the option to download _extensions_ to add functionalities like syntax highlighting and _live preview_.

Soon or later, you'll have to deal with things like encoding a complex tables, equations, nested lists, and some other stuff. And it can be time consuming to compile your document more than once just to check if the markup you wrote is ok. For that purpose, you can check them out quickly by using an AsciiDoc live preview provided by some extension.


== Tips

=== Always use lowercase image filenames

If you:

. have a file named `image.PNG`
. use this line to include it `image::image.png[]`

This will work on macOS and Windows, but will fail on Linux!

Linux uses case-sensitive file systems i.e. `image.PNG` and `image.png` are different file names
and Metanorma will fail to find the specified `image.png`.

If you are on windows, and have a bunch of filenames ending in .PNG, there is a straighforward way to change them all at once:

1. Go to the folder where the images are located.
2. Place the cursor in the bar address and write "cmd". The command line will open on that folder location.
3. On the command line, execute the command `ren *.PNG *.png`, and that's it!


=== Math

Do not use the `eqnarray` environment since it is not supported by `latexmlmath`.

If you want to know if an equation will pass, try this:

`math.lxml`
[source,latex]
----
V = \frac{1}{2} \: {\bf u}^t \:
            \int_{surface} \: {B'}^t \: D' \: B' \: ds
               \; {\bf u}
----

Run:

[source,sh]
----
cat math.lxml | latexmlmath -
----


=== Unnumbering elements

The attribute `%unnumbered` is used to remove the numbering from elements like: equation blocks, figures, tables, notes, examples, and code blocks. But not from sections and subsections:

[source,asciidoctor]
----
//Unnumbered image
[%unnumbered]
.Caption image
image::filename.png[]

//Unnumbered table
.Caption table
[%unnumbered]
|===
| This | is 
| a | table
|===

//Unnumbered equation
[stem%unnumbered]
++++
y = x^2
++++
----


=== Escaping characters

Like in normal AsciiDoc, you can espace special characters by prefixing the backslash (`\`) character to the character you want to espace. But, until certain point. There are some of cases where this approach will not work. For instance, if you wanted to render a double hyphen `--` instead of an em-dash `â€”`, you wouldn't be able to do it with "\--" (like in normal Asciidoc). Instead of that, you can use the _Zero Width Non Joiner_ entity `\&#x200c;`, applied on this way: `-\&#x200c;-`, and that will result in `--`. 

In general terms, you can try to escape first by using backslash, and if that doesn't happen to work, use `\&#x200c;` instead.


== FAQ

=== How can I nest additional content to a list item?

This is a recurrent situation indeed, and it can be handled by using open blocks:

----
--
This is an open block
--
----

Which, along with the concatenation character `+`, we can build:

.List item with block concatenation
----
. This line is a list item.
+
--
And this line is concatenated to the list item by using an open block.
--
----

.Result: List item with block concatenation
image::images/faq-1.png[]


You can basically put any markup into the concatenated open block: paragraphs, notes, examples, tables, lists, etc.


=== Why sometimes I get extremely wide tables in DOC output?

This happens because there is one or more cells containing long string characters that make the table wide beyond the borders of the page. In that case, you would need to include the `:break-up-urls-in-tables:` attribute in the preamble in order to divide in lines any long string characters, and thus, shrink the table.


See also: link:https://www.metanorma.com/author/ref/asciidoc-tips/[Metanorma AsciiDoc tips]


